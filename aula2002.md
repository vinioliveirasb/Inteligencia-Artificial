# ðŸ¤– Aula 2 â€” Fundamentos de IA, MÃ©todos de Busca e Tratamento de RestriÃ§Ãµes

---

# 1ï¸âƒ£ O que Ã© InteligÃªncia Artificial?

InteligÃªncia Artificial Ã© a Ã¡rea da ComputaÃ§Ã£o que desenvolve metodologias, tÃ©cnicas e algoritmos para resolver problemas complexos que normalmente exigiriam especialista.

A IA resolve problemas que:

- Possuem muitas restriÃ§Ãµes
- NÃ£o tÃªm estado final totalmente conhecido
- Precisam descobrir o passo-a-passo da soluÃ§Ã£o

Exemplos:
- Resolver um quebra-cabeÃ§a 3x3
- Reconhecer padrÃµes em imagens mÃ©dicas
- Encontrar o melhor caminho entre dois pontos

---

# 2ï¸âƒ£ Sistema de Comportamento Inteligente

Um sistema inteligente Ã© composto por:

## ðŸ”¹ 2.1 Base de Conhecimento
- Fatos, regras ou amostras.
- Funciona como memÃ³ria do sistema.

Exemplo:
Banco de imagens de pulmÃµes saudÃ¡veis e lesionados para treinar reconhecimento.

---

## ðŸ”¹ 2.2 RaciocÃ­nio Automatizado
- **Dedutivo** â†’ aplica regras para chegar a conclusÃµes.
- **Indutivo** â†’ aprende padrÃµes a partir de exemplos.

---

## ðŸ”¹ 2.3 MÃ©todos de Busca (Motor de ResoluÃ§Ã£o)

ResponsÃ¡vel por explorar possÃ­veis soluÃ§Ãµes.

### ðŸ“Œ Busca Cega (ForÃ§a Bruta)
- Busca em Amplitude (BFS)
- Busca em Profundidade (DFS)

Explora estados atÃ© encontrar a soluÃ§Ã£o.

### ðŸ“Œ MÃ©todos HeurÃ­sticos
- Guloso
- Subida de Encosta
- A*
- Algoritmo GenÃ©tico

Usam estratÃ©gias para reduzir o nÃºmero de estados explorados.

---

## ðŸ”¹ 2.4 Aprendizado de MÃ¡quina

- Baseado na repetiÃ§Ã£o de amostras.
- Quanto mais exemplos, melhor o sistema aprende.
- Ajusta desempenho ao longo do tempo.

---

# 3ï¸âƒ£ Modelagem de Problemas em IA

Para resolver um problema Ã© necessÃ¡rio definir:

- **Estados**
  - Inicial
  - Final (objetivo)

- **Regras de TransiÃ§Ã£o**
  - Como um estado pode mudar para outro

- **RestriÃ§Ãµes**
  - O que nÃ£o pode acontecer

- **Lista de Visitados**
  - Evita repetir estados

- **FunÃ§Ã£o Objetivo**
  - Define quando a soluÃ§Ã£o foi alcanÃ§ada

---

# 4ï¸âƒ£ Exemplo PrÃ¡tico â€” Quebra-cabeÃ§a 3x3

Problema:

Grade 3x3 com nÃºmeros de 1 a 8 e um espaÃ§o vazio.

Estado exemplo:

[1 2 3]  
[4 5 6]  
[7 _ 8]

O vazio estÃ¡ na **linha 3, coluna 2**.

---

# 5ï¸âƒ£ Tratamento de RestriÃ§Ãµes

O vazio:

- âŒ NÃ£o pode sair da matriz
- âŒ NÃ£o pode mover para baixo (jÃ¡ estÃ¡ na Ãºltima linha)
- âœ… Pode mover para cima
- âœ… Pode mover esquerda
- âœ… Pode mover direita

O movimento depende da posiÃ§Ã£o atual.

---

## ðŸ’» Exemplo de ValidaÃ§Ã£o (Python)

```python
def movimento_valido(linha, coluna, direcao):
    if direcao == "cima" and linha > 0:
        return True
    if direcao == "baixo" and linha < 2:
        return True
    if direcao == "esquerda" and coluna > 0:
        return True
    if direcao == "direita" and coluna < 2:
        return True
    return False
```

âš ï¸ A validaÃ§Ã£o deve buscar o erro.
Se a condiÃ§Ã£o nÃ£o for satisfeita, o movimento Ã© invÃ¡lido.

---

## ðŸ’» Gerando Novo Estado

```python
def mover(tabuleiro, linha, coluna, direcao):
    if not movimento_valido(linha, coluna, direcao):
        return None  # descarta estado invÃ¡lido
    
    novo = [linha[:] for linha in tabuleiro]

    if direcao == "cima":
        novo[linha][coluna], novo[linha-1][coluna] = novo[linha-1][coluna], novo[linha][coluna]

    if direcao == "baixo":
        novo[linha][coluna], novo[linha+1][coluna] = novo[linha+1][coluna], novo[linha][coluna]

    if direcao == "esquerda":
        novo[linha][coluna], novo[linha][coluna-1] = novo[linha][coluna-1], novo[linha][coluna]

    if direcao == "direita":
        novo[linha][coluna], novo[linha][coluna+1] = novo[linha][coluna+1], novo[linha][coluna]

    return novo
```

Estados invÃ¡lidos sÃ£o descartados imediatamente.

---

## ðŸ’» Exemplo Simplificado â€” Busca em Profundidade (DFS)

```python
def dfs(estado, objetivo, visitados):
    if estado == objetivo:
        return True

    visitados.append(estado)

    for movimento in ["cima", "baixo", "esquerda", "direita"]:
        novo_estado = gerar_estado(estado, movimento)

        if novo_estado and novo_estado not in visitados:
            if dfs(novo_estado, objetivo, visitados):
                return True

    return False
```

A busca explora estados atÃ© encontrar a soluÃ§Ã£o.

---

# âš ï¸ ObservaÃ§Ãµes Importantes

- No cÃ³digo, deve-se validar buscando o erro, nÃ£o o acerto.
- Estados invÃ¡lidos devem ser descartados imediatamente.
- Em forÃ§a bruta, a IA testa vÃ¡rias possibilidades.
- Se houver soluÃ§Ã£o, ela encontrarÃ¡ (desde que explore corretamente os estados).
- MÃ©todos heurÃ­sticos reduzem o custo computacional.

---

# âœ… Estrutura Final de um Sistema Inteligente

Base de Conhecimento  
+ RaciocÃ­nio  
+ MÃ©todo de Busca  
+ RestriÃ§Ãµes  
+ Aprendizado  
= Sistema de Comportamento Inteligente

---
---

# ðŸ§© Exemplo â€” Problema das N-Rainhas (Tabuleiro N x N)

Problema:

Dado um tabuleiro N x N, posicionar N rainhas de forma que nenhuma ataque a outra.

Uma rainha ataca:
- Mesma linha
- Mesma coluna
- Mesma diagonal

---

## ðŸ”¹ 1) Estados do Problema

RepresentaÃ§Ã£o:

- Matriz N x N
  - 0 â†’ posiÃ§Ã£o vazia
  - 1 â†’ existe rainha
- VariÃ¡vel inteira: qtdRainhas

### ðŸ“Œ Estado Inicial (N = 4)

```
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```

qtdRainhas = 0

---

### ðŸ“Œ Estado Final (Objetivo)

qtdRainhas = N  
E nenhuma rainha pode atacar outra.

Exemplo vÃ¡lido (N=4):

```
0 1 0 0
0 0 0 1
1 0 0 0
0 0 1 0
```

---

## ðŸ”¹ 2) Regras de TransiÃ§Ã£o (MÃ©todos)

OperaÃ§Ã£o possÃ­vel:

- Colocar uma rainha em uma posiÃ§Ã£o vazia (cÃ©lula == 0)

Cada inserÃ§Ã£o gera um novo estado.

---

## ðŸ”¹ 3) RestriÃ§Ãµes (ehValido)

O mÃ©todo deve verificar se o estado Ã© invÃ¡lido:

- Existe outra rainha na mesma linha?
- Existe outra rainha na mesma coluna?
- Existe outra rainha na mesma diagonal?

âš ï¸ Sempre validar buscando o erro.

---

## ðŸ’» Exemplo Simplificado â€” VerificaÃ§Ã£o de Coluna

```python
def coluna_valida(tabuleiro, coluna):
    for linha in range(len(tabuleiro)):
        if tabuleiro[linha][coluna] == 1:
            return False
    return True
```

Se retornar False â†’ estado invÃ¡lido.

---

## ðŸ”¹ 4) Visitados e Impacto no Desempenho

Durante a busca, precisamos armazenar estados jÃ¡ explorados para evitar repetiÃ§Ã£o.

A estrutura escolhida impacta diretamente no desempenho do algoritmo.

---

### ðŸ“Œ 4.1 Lista (Tradicional)

OperaÃ§Ãµes:
- add()
- contains()

ðŸ”Ž Complexidade:
- InserÃ§Ã£o â†’ O(1)
- Busca (contains) â†’ O(n)

Problema:
Quanto maior a lista, mais lenta fica a verificaÃ§Ã£o.
Em problemas com muitos estados (como N-Rainhas grande), o custo cresce muito.

âœ” Simples de implementar  
âŒ Escala mal para grandes espaÃ§os de busca  

---

### ðŸ“Œ 4.2 Ãrvore (ex: Ãrvore BinÃ¡ria)

ðŸ”Ž Complexidade mÃ©dia:
- InserÃ§Ã£o â†’ O(log n)
- Busca â†’ O(log n)

Melhora o desempenho comparado Ã  lista, pois nÃ£o precisa percorrer todos os elementos.

âœ” Melhor organizaÃ§Ã£o  
âœ” Mais eficiente que lista  
âŒ Ainda depende da estrutura estar balanceada  

---

### ðŸ“Œ 4.3 Hash (Ideal)

Ex: HashSet, HashMap

ðŸ”Ž Complexidade mÃ©dia:
- InserÃ§Ã£o â†’ O(1)
- Busca â†’ O(1)

Utiliza funÃ§Ã£o de hash para acessar diretamente a posiÃ§Ã£o do elemento.

âœ” Muito rÃ¡pido  
âœ” Ideal para grandes volumes de estados  
âœ” Melhor desempenho em busca cega  

---

## âš ï¸ Impacto na IA

Em mÃ©todos de forÃ§a bruta:

- Muitos estados sÃ£o gerados.
- A verificaÃ§Ã£o de visitados acontece constantemente.

Se a estrutura for lenta (lista), o algoritmo pode se tornar inviÃ¡vel.
Se for eficiente (hash), o desempenho melhora drasticamente.

ðŸ“Œ Portanto, a escolha da estrutura de dados influencia diretamente na eficiÃªncia da busca.
---

## ðŸ’» Modelagem em CÃ³digo â€” Problema das N-Rainhas (Java)

```java
public class Rainha {

    int[][] matriz;
    int qtdRainhas;

    // ðŸ”¹ 1) Construtor Inicial (Estado Inicial)
    public Rainha(int tamanhoTabuleiro) {
        this.matriz = new int[tamanhoTabuleiro][tamanhoTabuleiro];
        this.qtdRainhas = 0;

        for (int i = 0; i < tamanhoTabuleiro; i++) {
            for (int j = 0; j < tamanhoTabuleiro; j++) {
                matriz[i][j] = 0;
            }
        }
    }

    // ðŸ”¹ 2) Construtor IntermediÃ¡rio (Novo Estado baseado em outro)
    public Rainha(Rainha anterior) {
        int n = anterior.matriz.length;
        this.matriz = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                this.matriz[i][j] = anterior.matriz[i][j];
            }
        }

        this.qtdRainhas = anterior.qtdRainhas;
    }

    // ðŸ”¹ 3) Regra de TransiÃ§Ã£o (colocar rainha)
    public boolean colocarRainha(int linha, int coluna) {

        if (matriz[linha][coluna] == 1)
            return false;

        matriz[linha][coluna] = 1;
        qtdRainhas++;

        if (!ehValido(linha, coluna)) {
            matriz[linha][coluna] = 0;
            qtdRainhas--;
            return false;
        }

        return true;
    }

    // ðŸ”¹ 4) RestriÃ§Ãµes (validaÃ§Ã£o do estado)
    private boolean ehValido(int linha, int coluna) {

        int n = matriz.length;

        // Verifica coluna
        for (int i = 0; i < n; i++) {
            if (i != linha && matriz[i][coluna] == 1)
                return false;
        }

        // Verifica linha
        for (int j = 0; j < n; j++) {
            if (j != coluna && matriz[linha][j] == 1)
                return false;
        }

        // Verifica diagonais
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if ((i != linha || j != coluna) &&
                    Math.abs(i - linha) == Math.abs(j - coluna) &&
                    matriz[i][j] == 1)
                    return false;
            }
        }

        return true;
    }

    // ðŸ”¹ 5) Estado Final (FunÃ§Ã£o Objetivo)
    public boolean ehObjetivo() {
        return qtdRainhas == matriz.length;
    }
}
```
